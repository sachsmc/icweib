{
    "collab_server" : "",
    "contents" : "icweib <-\nfunction(L, R, data, strata=\"ALL\", covariates=NULL, weights) {\n  Call <- match.call()\n  if (is.name(Call$strata) | is.call(Call$strata)) {\n  \tstraname <- deparse(Call$strata)\n  } else {\n  \tstraname <- \"strata\"\n  }\n  ## Get strata, left time, right time\n  strata <- eval(substitute(strata), data, parent.frame())\t\n  Lt <- eval(substitute(L), data, parent.frame())\t\n  Rt <- eval(substitute(R), data, parent.frame())\n  if (length(strata)==1) strata <- rep(strata, length(Lt))\n  Lt <- as.vector(Lt)\n  Rt <- as.vector(Rt)\n  if (!is.numeric(Lt) | !is.numeric(Rt)) stop(\"L and R must be numeric variables\")\n  strata <- as.vector(strata)\t\n  \n  ## Model Frame\n  if (is.null(covariates)) {\n  \tmframe <- NULL\n  \tdesign <- NULL\n  \tbeta.nm <- NULL\n  \tnbeta <- 0\n  } else {\n    mframe <-  model.frame(covariates, data=data, na.action=na.pass) \t\n  }\n  \n  if (missing(weights)) {\n    weights <- rep(1, length(Lt))\n  } else {\n    weights <- eval(substitute(weights), data, parent.frame())\n  }\n\n  ## Compare lengths\n  if (length(unique(c(length(Lt), length(Rt), length(weights), length(strata), dim(mframe)[1])))!=1)\n     stop(\"L, R, weights, strata, and data must have same length\")\n     \n  ## Remove missing\n  nmiss <- complete.cases(cbind(Lt, Rt, strata, mframe))\n  validtime <- (Lt >= 0) & (Rt > 0) & (Rt - Lt >= 0)\n  validtime[is.na(validtime)] <- F\n  keep <- nmiss & validtime\n  delete <- which(!keep)\n  ndel <- length(delete)\t\n  n <- sum(keep)\n  Lt <- Lt[keep]\n  Rt <- Rt[keep]\n  strata <- strata[keep]\n  mframe <- mframe[keep, , drop=F]\n  \n  ## Design matrix\n  if (!is.null(covariates)) {\n  \tdesign <- model.matrix(covariates, data=mframe)[, -1, drop=F]\n  \tbeta.nm <- colnames(design)\n    nbeta <- dim(design)[2]\n  }\n\t\n  ## Design matrix for strata\n  levels <- sort(unique(strata))\n  nstr <- length(levels)\n  dstrata <- outer(strata, levels, \"==\")*1\n  stra.nm <- paste(c(rep(\"v\", nstr), rep(\"u\", nstr)), rep(levels, 2), sep=\":\")\n  \n  ## Time information\n  allt <- c(Lt, Rt)\n  maxT <- max(allt[allt!=Inf])\n  meanT <- mean(allt[allt!=0 & allt!=Inf])\n  vini <- -log(meanT)\n\n  ## Get event status to see if any event\n  et <- Lt==Rt\n  event <- sum(et) > 0\n  if (event) {\n  \tie <- which(et)\n  \tdstratae <- dstrata[et, ]\n  \tdesigne <- design[et, ]\n  \tRt[et] <- Inf  \t\n  }\n  \t\n  ## Log-likelihood function\n  LLt <- log(Lt)\n  RRt <- log(Rt)\t\n  loglik <- function(parms) {\n    v <- dstrata%*%parms[1:nstr]\n    ev <- exp(v)\n    u <- dstrata%*%parms[(nstr+1):(2*nstr)]\n    if (nbeta > 0) {prog <- design%*%parms[-(1:(2*nstr))]} else {prog <- rep(0, n)}\n    lik <- sum(weights * log(exp(-exp(u + prog + ev*LLt)) - exp(-exp(u + prog + ev*RRt))))\n    if (event) lik <- lik + sum(weights[ie] * (u[ie] + prog[ie] + v[ie] + (ev[ie]-1)*LLt[ie]))\n    return(-lik)\t\n  }\n  \t\n  ## Gradient function\t\t\n  gradlik <-function(parms) {\t\n    v <- dstrata%*%parms[1:nstr]\n    ev <- c(exp(v))\n    u <- dstrata%*%parms[(nstr+1):(2*nstr)]\n    if (nbeta > 0) {prog <- design%*%parms[-(1:(2*nstr))]} else {prog <- 0}\n    SL <- exp(-exp(u + prog + ev*LLt))\n    SR <- exp(-exp(u + prog + ev*RRt))\n    SLL <- c(SL*exp(u + prog + ev*LLt))\n    SRR <- c(ifelse(Rt==Inf, 0, SR*exp(u + prog + ev*RRt)))\n    Dev0 <- ((cbind(ifelse(Lt==0, 0, LLt)*ev*dstrata, dstrata, design)*SLL - \n           cbind(ifelse(Rt==Inf, 0, RRt)*ev*dstrata, dstrata, design)*SRR)/c(SL-SR))\n    wts <- matrix(rep(weights, ncol(Dev0)), ncol = ncol(Dev0))\n    Dev <- colSums(Dev0 * wts)\n    if (event) Dev <- Dev - colSums(cbind((1+LLt[ie]*ev[ie])*dstratae, dstratae, designe) * wts)\n    \n    return(Dev)\n  }\n\n  ## Optimization\n  parmi <- c(rep(0, nstr), rep(vini, nstr), rep(0, nbeta))\n  q <- optim(parmi, loglik, gradlik, method=\"BFGS\", hessian=T)\n  if (q$convergence!=0)\twarning(\"Full model not converged\")\n\t\n  ## Covariance matrix\n  covm <- solve(q$hessian)\t\n  \n  ## Fit NULL model, no covariates\n  loglik0 <- function(parms) {\n    v <- dstrata%*%parms[1:nstr]\n    ev <- exp(v)\n    u <- dstrata%*%parms[(nstr+1):(2*nstr)]\n    lik <- sum(log(exp(-exp(u + ev*LLt)) - exp(-exp(u + ev*RRt))))\n    if (event) lik <- lik + sum(u[ie] + v[ie] + (ev[ie]-1)*LLt[ie])\n    return(-lik) \t\n  }\n  gradlik0 <- function(parms) {\n    v <- dstrata%*%parms[1:nstr]\n    ev <- c(exp(v))\n    u <- dstrata%*%parms[(nstr+1):(2*nstr)]\n    SL <- exp(-exp(u + ev*LLt))\n    SR <- exp(-exp(u + ev*RRt))\n    SLL <- c(SL*exp(u + ev*LLt))\n    SRR <- c(ifelse(Rt==Inf, 0, SR*exp(u + ev*RRt)))\n    Dev <- colSums((cbind(ifelse(Lt==0, 0, LLt)*ev*dstrata, dstrata)*SLL - \n           cbind(ifelse(Rt==Inf, 0, RRt)*ev*dstrata, dstrata)*SRR)/c(SL-SR))\n    if (event) Dev <- Dev - colSums(cbind((1+LLt[ie]*ev[ie])*dstratae, dstratae))\n    return(Dev)  \n  }\n  parmi0 <- c(rep(0, nstr), rep(vini, nstr))\n  q0 <- optim(parmi0, loglik0, gradlik0, method=\"BFGS\")\n  \t\n  ## Fit the reduced model: shape parameters are all equal if there are more than 1 strata\n  if (nstr > 1) {\n    loglik1 <- function(parms) {\n      v <- parms[1]\n      ev <- exp(v)\n      u <- dstrata%*%parms[2:(nstr+1)]\n      if (nbeta > 0) {prog <- design%*%parms[-(1:(nstr+1))]} else {prog <- rep(0, n)}\n      lik <- sum(log(exp(-exp(u + prog + ev*LLt)) - exp(-exp(u + prog + ev*RRt))))\n      if (event) lik <- lik + sum(u[ie] + prog[ie] + v + (ev-1)*LLt[ie])\n      return(-lik)\t\n\t}\t\n\tgradlik1 <-function(parms) {\n      v <- parms[1]\n      ev <- exp(v)\n      u <- dstrata%*%parms[2:(nstr+1)]\n      if (nbeta > 0) {prog <- design%*%parms[-(1:(nstr+1))]} else {prog <- 0}\n      SL <- exp(-exp(u + prog + ev*LLt))\n      SR <- exp(-exp(u + prog + ev*RRt))\n      SLL <- c(SL*exp(u + prog + ev*LLt))\n      SRR <- c(ifelse(Rt==Inf, 0, SR*exp(u + prog + ev*RRt)))\n      Dev <- colSums((cbind(ifelse(Lt==0, 0, LLt)*ev, dstrata, design)*SLL - \n              cbind(ifelse(Rt==Inf, 0, RRt)*ev, dstrata, design)*SRR)/c(SL-SR))\n      if (event) Dev <- Dev - colSums(cbind(1+LLt[ie]*ev, dstratae, designe))\n      return(Dev)\n\t}\n    parmi1 <- c(0, rep(vini, nstr), rep(0, nbeta))\n    q1 <- optim(parmi1, loglik1, gradlik1, method=\"BFGS\")\n    if (q1$convergence!=0)\twarning(\"Reduced model not converged\")\n\t\n\t## Get likelihood ratio test statistic\n    df <- nstr - 1\n    testlik <- 2*(q1$value - q$value)\n    plik <- 1 - pchisq(testlik, df)\n    likratio <- data.frame(test=\"Likelihood Ratio\", TestStat=testlik, df, p.value=plik)\n\n\t## Wald test statistic\n    covv <- covm[1:nstr,1:nstr]\n    estv <- q$par[1:nstr]\n    testM <- t(sapply(1:(nstr-1), function(x) c(rep(0, x-1), c(1, -1), rep(0, nstr-x-1))))\n    testwald <- t(testM%*%estv)%*%solve(testM%*%covv%*%t(testM))%*%(testM%*%estv)\n    pwald <- 1 - pchisq(testwald, df)\n    tWald <- data.frame(test=\"Wald\", TestStat=testwald, df, p.value=pwald)\n\t\n\t## Combine test statistics\n    stratatest <- rbind(tWald, likratio)\t\t\n    } else {\n      stratatest <- NA\n      q1 <- list(value=NA)\n    }\n\n\t## report results\n    rownames(covm) <- colnames(covm) <- c(stra.nm, beta.nm)\n    logliks <- c(-q$value, -q1$value, -q0$value)\n    names(logliks) <- c(\"full\", \"reduced\", \"null\")\n    if (nbeta > 0) {\n\t  beta.fit <- q$par[-(1:(2*nstr))]\n\t  beta.sd <- sqrt(diag(covm)[-(1:(2*nstr))])\n\t  beta.z <- beta.fit/beta.sd\n\t  p.value <- 2 * (1 - pnorm(abs(beta.z)))\n\t  coef <- data.frame(coefficient = beta.fit, SE = beta.sd, z = beta.z, p.value = p.value) \n\t  rownames(coef) <- beta.nm    \t\n    } else {\n      coef <- NA\n    }\n\tweib <- data.frame(straname=straname, strata=levels, gamma = exp(q$par[1:nstr]),\n\t             lambda = exp(q$par[(nstr+1):(2*nstr)]), stringsAsFactors=F)\n\tns <- c(n, nstr, nbeta, ndel)\n\tnames(ns) <- c(\"nused\", \"nstrata\", \"ncovariates\", \"ndeleted\")\n\tz <- list(loglik=logliks, coef=coef, weib=weib, stratatest=stratatest, cov=covm, ns=ns, delete=delete, maxT=maxT, q=q)\n\tclass(z) <- \"icweib\"\n\treturn(z)\n}\n",
    "created" : 1487319104456.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3740446627",
    "id" : "C49B553F",
    "lastKnownWriteTime" : 1487322030,
    "last_content_update" : 1487322063262,
    "path" : "G:/STAFF/Michael Sachs/R projects/straweib/R/icweib.R",
    "project_path" : "R/icweib.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}